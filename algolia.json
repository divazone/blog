[{"categories":["vscode"],"content":"簡單紀錄一下我在VS Code裡面裝了哪些插件 ","date":"2024-03-21","objectID":"/2024/03/20240321-vscode-plugins/:0:0","tags":["vscode"],"title":"我在VS Code裡面用了哪些插件","uri":"/2024/03/20240321-vscode-plugins/"},{"categories":["vscode"],"content":"Cloud維運 Ansible Terraform Dev Containers Kubernetes Remote - SSH - 可使用VS Code遠端連線開發 DotENV - .env syntax highlighting ","date":"2024-03-21","objectID":"/2024/03/20240321-vscode-plugins/:1:0","tags":["vscode"],"title":"我在VS Code裡面用了哪些插件","uri":"/2024/03/20240321-vscode-plugins/"},{"categories":["vscode"],"content":"文字編輯相關 YAML - YAML 檔的 syntax highlight Code Spell Checker - 檢測拼字錯誤 Even Better TOML - TOML 檔的 syntax highlight indent-rainbow - 縮排美化 ","date":"2024-03-21","objectID":"/2024/03/20240321-vscode-plugins/:2:0","tags":["vscode"],"title":"我在VS Code裡面用了哪些插件","uri":"/2024/03/20240321-vscode-plugins/"},{"categories":["vscode"],"content":"Golang Go ","date":"2024-03-21","objectID":"/2024/03/20240321-vscode-plugins/:3:0","tags":["vscode"],"title":"我在VS Code裡面用了哪些插件","uri":"/2024/03/20240321-vscode-plugins/"},{"categories":["vscode"],"content":"Python Python Python Debugger Pylance - 微軟的Python Language Server Flake8 - Python Linter，符合PEP 8規範 Black Formatter - Python Formatter，符合PEP 8規範 isort - import排序，符合PEP 8規範 autoDocstring - Python Docstring Generator - 自動生產docstring，符合PEP 257規範 ","date":"2024-03-21","objectID":"/2024/03/20240321-vscode-plugins/:4:0","tags":["vscode"],"title":"我在VS Code裡面用了哪些插件","uri":"/2024/03/20240321-vscode-plugins/"},{"categories":["vscode"],"content":"git相關 Git History - 可視化的git log GitLens — Git supercharged - 強大的git extension in VS Code Git Graph - 方便查看git分支圖形 ","date":"2024-03-21","objectID":"/2024/03/20240321-vscode-plugins/:5:0","tags":["vscode"],"title":"我在VS Code裡面用了哪些插件","uri":"/2024/03/20240321-vscode-plugins/"},{"categories":["vscode"],"content":"Hugo工作流程(Markdown編輯) Hugo Language and Syntax Support Hugo Shortcode Syntax Highlighting Hugo Snippets Markdown All in One Markdown Preview Mermaid Support Marp for VS Code - 做 Marp Markdown 簡報的套件 Mermaid Markdown Syntax Highlighting Path Intellisense - 選擇圖檔路徑時節省時間 ","date":"2024-03-21","objectID":"/2024/03/20240321-vscode-plugins/:6:0","tags":["vscode"],"title":"我在VS Code裡面用了哪些插件","uri":"/2024/03/20240321-vscode-plugins/"},{"categories":["vscode"],"content":"佈景主題 Chinese (Traditional) Language Pack for Visual Studio Code One Dark Pro - VS Code主題 Material Icon Theme - VS Code icon主題 ","date":"2024-03-21","objectID":"/2024/03/20240321-vscode-plugins/:7:0","tags":["vscode"],"title":"我在VS Code裡面用了哪些插件","uri":"/2024/03/20240321-vscode-plugins/"},{"categories":["vscode"],"content":"settings.json設定 { \"workbench.iconTheme\": \"material-icon-theme\", \"workbench.colorTheme\": \"One Dark Pro Darker\", \"[python]\": { \"editor.defaultFormatter\": \"ms-python.black-formatter\", \"editor.codeActionsOnSave\": { \"source.organizeImports\": \"explicit\" } }, \"flake8.args\": [ \"--max-line-length=100\", \"--ignore=E131,E302\" ], \"black-formatter.args\": [ \"--line-length=100\", \"--skip-string-normalization\" ], \"isort.args\": [ \"--src=${workspaceFolder}\", \"--line-length=100\" ], \"isort.check\": true, \"autoDocstring.docstringFormat\": \"google-notypes\", \"git.ignoreRebaseWarning\": true, \"files.eol\": \"\\n\" } ","date":"2024-03-21","objectID":"/2024/03/20240321-vscode-plugins/:8:0","tags":["vscode"],"title":"我在VS Code裡面用了哪些插件","uri":"/2024/03/20240321-vscode-plugins/"},{"categories":["container"],"content":"寫在前面 ","date":"2024-03-13","objectID":"/2024/03/20240313-edit-docker-container-file/:1:0","tags":["container"],"title":"編輯docker容器中的文件","uri":"/2024/03/20240313-edit-docker-container-file/"},{"categories":["container"],"content":"為什麼要這麼做？ 實際上我們並不需要也不需要直接編輯容器中的檔案。Docker 容器是不可修改的工作單元，用於運行單一、特定的進程。鏡像應該在沒有任何影響的情況下能夠被建立和運行。 只是在開發期間，對 Docker 容器中的文件進行編輯可能才有些用處，這讓我們在不需要重新建立鏡像的狀態下驗證是否達到了預期的效果，可以達到節省時間、提高開發效率的目的，但是在完成驗證後，應該刪除增加到鏡像中的多於內容，使驗證後的結果永久化到鏡像中。 另外需要提醒的一點是，當我們在一個運行著的容器中編輯一個文件後需要確保所依賴的這個文件的process收到了文件編輯的通知並進行了設定更新，如果沒有類似的通知機制，需要手動重啟這些process使修改能生效。 下面假設你所使用的容器中沒有 vi 等文字編輯工具，我們以 openjdk:23 作為示範： docker run -it openjdk:23 bash root@d0fb3a0b527c:/# vi demo.java bash: vi: command not found root@d0fb3a0b527c:/# ","date":"2024-03-13","objectID":"/2024/03/20240313-edit-docker-container-file/:1:1","tags":["container"],"title":"編輯docker容器中的文件","uri":"/2024/03/20240313-edit-docker-container-file/"},{"categories":["container"],"content":"以下介紹五種常用方法： ","date":"2024-03-13","objectID":"/2024/03/20240313-edit-docker-container-file/:2:0","tags":["container"],"title":"編輯docker容器中的文件","uri":"/2024/03/20240313-edit-docker-container-file/"},{"categories":["container"],"content":"方法1：使用掛載 準備Dockerfile： FROM openjdk:23 WORKDIR \"/app\" 編譯鏡像： docker build -t sample . 最後，運行標記為掛載的容器： docker run --rm -it --name=sample_demo -v $PWD/app-vol:/app sample bash 如果本機 $PWD/app-vol 目錄不存在，會自動建立。此後在 $PWD/app-vol 下的檔案操作會對應在容器的 /app 目錄下。 ","date":"2024-03-13","objectID":"/2024/03/20240313-edit-docker-container-file/:2:1","tags":["container"],"title":"編輯docker容器中的文件","uri":"/2024/03/20240313-edit-docker-container-file/"},{"categories":["container"],"content":"方法2：安裝編輯器 準備Dockerfile： FROM openjdk:23 WORKDIR \"/app\" 編譯鏡像： docker build -t sample . 啟動容器並進行vim編輯器安裝： docker run --rm -it --name=sample_demo sample bash root@4b72fbabb0af:/app# apt-get update root@4b72fbabb0af:/app# apt-get -y install vim 如果需要重複使用，更好的做法是寫在 Dockerfile 中： FROM openjdk:23 RUN [\"apt-get\", \"update\"] RUN [\"apt-get\", \"-y\", \"install\", \"vim\"] WORKDIR \"/app\" ","date":"2024-03-13","objectID":"/2024/03/20240313-edit-docker-container-file/:2:2","tags":["container"],"title":"編輯docker容器中的文件","uri":"/2024/03/20240313-edit-docker-container-file/"},{"categories":["container"],"content":"方法3：將文件複製到正在運行的容器中 docker cp demo.java sample_demo:/app 另一個類似的方法只要 docker exec 和 cat 結合使用，下面的指令同樣把 demo.java 檔案複製到正在運作的容器中： docker exec -i sample_demo sh -c 'cat \u003e /app/demo.java' \u003c demo.java ","date":"2024-03-13","objectID":"/2024/03/20240313-edit-docker-container-file/:2:3","tags":["container"],"title":"編輯docker容器中的文件","uri":"/2024/03/20240313-edit-docker-container-file/"},{"categories":["container"],"content":"方法4：使用Linux工具 雖然容器中通常沒有安裝編輯工具，但是其他Linux工具，如：sed、awk、echo、cat、cut等還是有的，可以派上用場。例如sed和awk可以編輯文件的適當位置，還可以將echo , cat, cut 聯合起來並藉助強大的指令流和編輯文件。如前文所示，這些工具可以與docker exec 命令結合使用，從而發揮更強大的威力。 ","date":"2024-03-13","objectID":"/2024/03/20240313-edit-docker-container-file/:2:4","tags":["container"],"title":"編輯docker容器中的文件","uri":"/2024/03/20240313-edit-docker-container-file/"},{"categories":["container"],"content":"方法5：使用遠端vim（或其他編輯器） 這種方法只是為了開拓思路，並不會在實際中使用，因為並不安全。 準備Dockerfile： FROM openjdk:23 RUN [\"apt-get\", \"update\"] RUN [\"apt-get\", \"install\", \"-y\", \"openssh-server\"] RUN mkdir /var/run/sshd RUN echo 'root:password' | chpasswd RUN sed -i 's/#PermitRootLogin prohibit-password/PermitRootLogin yes/' /etc/ssh/sshd_config RUN [\"/etc/init.d/ssh\", \"start\"] EXPOSE 22 WORKDIR \"/app\" CMD [\"/usr/sbin/sshd\", \"-D\"] 因為我們要藉助 scp 來遠端進行檔案編輯，所以需要安裝 openssh-server 並開放其連接埠。 編譯並運行： docker build -t sample . docker run --rm -p 2222:22 -d --name=sample_demo sample 現在我們可以使用以下指令來編輯demo.java檔了： vim scp://root@localhost:2222//app/demo.java 註：在 vi 需要先執行 :set bt=acwrite 指令再去編輯文件，相關討論請見：https://github.com/vim/vim/issues/2329 編輯完成儲存並退出後，可以使用下面的命令來驗證檔案確實被建立和儲存了： docker exec -it sample_demo cat /app/demo.java ","date":"2024-03-13","objectID":"/2024/03/20240313-edit-docker-container-file/:2:5","tags":["container"],"title":"編輯docker容器中的文件","uri":"/2024/03/20240313-edit-docker-container-file/"},{"categories":["linux"],"content":"我們在登入伺服器，執行一個較耗時的程式時，通常我們會使用 nohup command \u0026 的方式執行，如果我們在啟動時，忘記加上這 nohup 能否成功呢？ 首先使用 control + z 讓目前process暫停（Suspend）。 然後我們使用 jobs 來查看它的jobspec。 再用 bg %jobspec 來放入背景並繼續執行。 最後使用 disown -h %jobspec 來使該作業忽略 HUP 訊號。 這個方法可以用在 scp 的指令中，在沒有設定 ssh 無密碼登入的情況下，我們無法使用 nohup 來執行 scp 指令，所以只能在開始大檔案copy後，透過上述方法讓這個程式被放置在背景執行。 ","date":"2024-03-11","objectID":"/2024/03/20240311-run-in-background/:0:0","tags":["linux","nohup"],"title":"把程式移動至背景執行的方式","uri":"/2024/03/20240311-run-in-background/"},{"categories":["linux"],"content":"References Shell Scripting – JOB SPEC \u0026 Command ","date":"2024-03-11","objectID":"/2024/03/20240311-run-in-background/:1:0","tags":["linux","nohup"],"title":"把程式移動至背景執行的方式","uri":"/2024/03/20240311-run-in-background/"},{"categories":["java"],"content":"方法有這三種 使用hibernate.cfg.xml文件建立Hibernate SessionFactory 使用Java HashMap和ServiceRegistry class在Hibernate中建立SessionFactory 從JPA的EntityManager中獲得Hibernate SessionFactory ","date":"2023-05-08","objectID":"/2023/05/20230119-hibernate-sessionfactory/:0:0","tags":["hibernate","java"],"title":"在Java中建立Hibernate SessionFactory的三種方法","uri":"/2023/05/20230119-hibernate-sessionfactory/"},{"categories":["java"],"content":"1. 使用hibernate.cfg.xml文件建立Hibernate SessionFactory 這是官方建議的方法，hibernate.cfg.xml內容如下: \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003c!DOCTYPE hibernate-configuration PUBLIC \"-//Hibernate/Hibernate Configuration DTD 3.0//EN\" \"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\"\u003e \u003chibernate-configuration\u003e \u003csession-factory\u003e \u003cproperty name=\"connection.driver_class\"\u003ecom.mysql.cj.jdbc.Driver\u003c/property\u003e \u003c!-- property name=\"connection.driver_class\"\u003ecom.mysql.jdbc.Driver\u003c/property --\u003e \u003cproperty name=\"connection.url\"\u003ejdbc:mysql://localhost/hibernate_examples\u003c/property\u003e \u003cproperty name=\"connection.username\"\u003eroot\u003c/property\u003e \u003cproperty name=\"connection.password\"\u003epassword\u003c/property\u003e \u003cproperty name=\"connection.pool_size\"\u003e3\u003c/property\u003e \u003cproperty name=\"dialect\"\u003eorg.hibernate.dialect.MySQL8Dialect\u003c/property\u003e \u003cproperty name=\"current_session_context_class\"\u003ethread\u003c/property\u003e \u003cproperty name=\"show_sql\"\u003etrue\u003c/property\u003e \u003cproperty name=\"format_sql\"\u003etrue\u003c/property\u003e \u003cproperty name=\"hbm2ddl.auto\"\u003eupdate\u003c/property\u003e \u003c!-- mapping class=\"com.mcnz.jpa.examples.Player\" / --\u003e \u003c/session-factory\u003e \u003c/hibernate-configuration\u003e 接著在就可以在Java內去建立Hibernate SessionFactory: public static Session getCurrentSessionFromConfig() { // SessionFactory in Hibernate 5 example Configuration config = new Configuration(); config.configure(); // local SessionFactory bean created SessionFactory sessionFactory = config.buildSessionFactory(); Session session = sessionFactory.getCurrentSession(); return session; } ","date":"2023-05-08","objectID":"/2023/05/20230119-hibernate-sessionfactory/:1:0","tags":["hibernate","java"],"title":"在Java中建立Hibernate SessionFactory的三種方法","uri":"/2023/05/20230119-hibernate-sessionfactory/"},{"categories":["java"],"content":"2. 使用Java HashMap和ServiceRegistry class在Hibernate中建立SessionFactory 個人覺得用xml檔來儲存像是資料庫位址與帳密實在是太危險，好在能夠使用一個HashMap來把資料儲存起來傳送給ServiceRegistry，這樣就不需要去建立hibernate.cfg.xml了 更正:將資料庫與帳密等變數資訊加密後放置在主機的環境變數會是較好的做法 public static Session getCurrentSession() { // Hibernate 5.4 SessionFactory example without XML Map\u003cString, String\u003e settings = new HashMap\u003c\u003e(); settings.put(\"connection.driver_class\", \"com.mysql.jdbc.Driver\"); settings.put(\"dialect\", \"org.hibernate.dialect.MySQL8Dialect\"); settings.put(\"hibernate.connection.url\", \"jdbc:mysql://localhost/hibernate_examples\"); settings.put(\"hibernate.connection.username\", \"root\"); settings.put(\"hibernate.connection.password\", \"password\"); settings.put(\"hibernate.current_session_context_class\", \"thread\"); settings.put(\"hibernate.show_sql\", \"true\"); settings.put(\"hibernate.format_sql\", \"true\"); ServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder() .applySettings(settings).build(); MetadataSources metadataSources = new MetadataSources(serviceRegistry); // metadataSources.addAnnotatedClass(Player.class); Metadata metadata = metadataSources.buildMetadata(); // here we build the SessionFactory (Hibernate 5.4) SessionFactory sessionFactory = metadata.getSessionFactoryBuilder().build(); Session session = sessionFactory.getCurrentSession(); return session; } ","date":"2023-05-08","objectID":"/2023/05/20230119-hibernate-sessionfactory/:2:0","tags":["hibernate","java"],"title":"在Java中建立Hibernate SessionFactory的三種方法","uri":"/2023/05/20230119-hibernate-sessionfactory/"},{"categories":["java"],"content":"3. 從JPA的EntityManager中獲得Hibernate SessionFactory 直接使用JPA去取得 hibernate session內的資料 public static SessionFactory getCurrentSessionFromJPA() { // JPA and Hibernate SessionFactory example EntityManagerFactory emf = Persistence.createEntityManagerFactory(\"jpa-tutorial\"); EntityManager entityManager = emf.createEntityManager(); // Get the Hibernate Session from the EntityManager in JPA Session session = entityManager.unwrap(org.hibernate.Session.class); SessionFactory factory = session.getSessionFactory(); return factory; } ","date":"2023-05-08","objectID":"/2023/05/20230119-hibernate-sessionfactory/:3:0","tags":["hibernate","java"],"title":"在Java中建立Hibernate SessionFactory的三種方法","uri":"/2023/05/20230119-hibernate-sessionfactory/"},{"categories":["java"],"content":"References Build a Hibernate SessionFactory by example ","date":"2023-05-08","objectID":"/2023/05/20230119-hibernate-sessionfactory/:4:0","tags":["hibernate","java"],"title":"在Java中建立Hibernate SessionFactory的三種方法","uri":"/2023/05/20230119-hibernate-sessionfactory/"},{"categories":["aws"],"content":"在使用AWS Lambda的時候，發現它裡面的時區並不會使用使用者帳號所設定的時區，都是使用UTC時區。 如果要改變AWS Lambda所使用的時區的話，只要去各Lambda function的Environment variables裡面設定就可以了 ","date":"2023-05-08","objectID":"/2023/05/20230508-aws-timezone/:0:0","tags":["aws"],"title":"AWS Lambda 時區變更","uri":"/2023/05/20230508-aws-timezone/"},{"categories":["aws"],"content":"Environment variables Key Value Tz Asia/Taipei ","date":"2023-05-08","objectID":"/2023/05/20230508-aws-timezone/:1:0","tags":["aws"],"title":"AWS Lambda 時區變更","uri":"/2023/05/20230508-aws-timezone/"},{"categories":["java"],"content":"1. HQL（Hibernate Query Language） @Override public SysUser findUserByLoginName(String pLoginName) { String hql = \"from SysUser as u where u.loginName = ?\"; List\u003cSysUser\u003e users = getHibernateTemplate().find(hql, pLoginName); return users.isEmpty() ? null : users.get(0); } ","date":"2023-05-08","objectID":"/2023/05/20230508-hibernate-query/:1:0","tags":["hibernate","java"],"title":"Hibernate三種查詢資料的方式","uri":"/2023/05/20230508-hibernate-query/"},{"categories":["java"],"content":"2. SQL（Structured Query Language） static List sql() { Session s = HibernateUtil.getSession(); Query q = s.createSQLQuery(\"select * from user\").addEntity(User.class); List\u003cUser\u003e rs = q.list(); s.close(); return rs; } ","date":"2023-05-08","objectID":"/2023/05/20230508-hibernate-query/:2:0","tags":["hibernate","java"],"title":"Hibernate三種查詢資料的方式","uri":"/2023/05/20230508-hibernate-query/"},{"categories":["java"],"content":"3. QBC（Query By Criteria） //查詢符合條件的帳號 Criteria c=s.createCriteria(Admin.class); c.add(Restrictions.eq(\"aname\",name)); c.add(Restrictions.eq(\"apassword\", password)); List\u003cAdmin\u003e list=c.list(); //列出分頁前10項 Criteria criteria = session.createCriteria(Customer.class); criteria.addOrder( Order.asc(\"name\") ); //排序方式 criteria.setFirstResult(0); criteria.setMaxResults(10); List result = criteria.list（） ","date":"2023-05-08","objectID":"/2023/05/20230508-hibernate-query/:3:0","tags":["hibernate","java"],"title":"Hibernate三種查詢資料的方式","uri":"/2023/05/20230508-hibernate-query/"},{"categories":["misc"],"content":"總之是個值得紀念的第一個文章 ","date":"2023-01-19","objectID":"/2023/01/first-post/:0:0","tags":["misc"],"title":"First Post","uri":"/2023/01/first-post/"},{"categories":null,"content":"贊助 Donate","date":"2023-01-19","objectID":"/donate/","tags":null,"title":"贊助 Donate","uri":"/donate/"},{"categories":null,"content":"如果你覺得我的文章很棒，可以贊助我一杯咖啡 點我連結 ","date":"2023-01-19","objectID":"/donate/:0:0","tags":null,"title":"贊助 Donate","uri":"/donate/"},{"categories":null,"content":"About Divazone King","date":"2022-07-09","objectID":"/about/","tags":null,"title":"About Divazone King","uri":"/about/"},{"categories":null,"content":"Just a software engineer ","date":"2022-07-09","objectID":"/about/:0:0","tags":null,"title":"About Divazone King","uri":"/about/"}]